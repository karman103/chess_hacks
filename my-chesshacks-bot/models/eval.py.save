§import chess
import chess.engine
import torch
import os
os.environ["PYTORCH_JIT_USE_NNPACK"] = "0"

import random
import argparse

from model2 import PolicyValueNet, MCTS, board_to_tensor, index_to_move


###############################################
# Model move via MCTS
###############################################
def model_move(board, model, sims=64, device="cpu"):
    mcts = MCTS(model, sims=sims, cpuct=1.5, device=device)
    pi = mcts.run(board)
    idx = int(torch.argmax(pi))
    move = index_to_move(idx)

    if move not in board.legal_moves:
        move = random.choice(list(board.legal_moves))
    return move


###############################################
# Play ONE game at Stockfish LEVEL
###############################################
def play_game_at_level(model, sf_path, sf_level, model_white, sims, device):

    board = chess.Board()
    engine = chess.engine.SimpleEngine.popen_uci(sf_path)
	
    elo_mapping = {
	1: 1350,
	2: 1400,
	3: 1500,
	4: 1600,
	5: 1850,
	7: 2000,
	8: 2150
     }	
    # --- REAL WEAKENING THAT WORKS ON ALL STOCKFISH BUILDS ---
    engine.configure({
        "Skill Level": sf_level,            # 0–20
        "UCI_LimitStrength": True,
	"UCI_Elo": elo_mapping.get(sf_level, 1500)
    })

    # Depth scaling (critical)
    sf_depth = 1 + sf_level  # SF1→depth2, SF8→depth9

    while not board.is_game_over():

        if (board.turn == chess.WHITE and model_white) or \
           (board.turn == chess.BLACK and not model_white):

            move = model_move(board, model, sims=sims, device=device)

        else:
            # Stockfish move at bounded depth
            result = engine.play(board, chess.engine.Limit(depth=sf_depth))
            move = result.move

        board.push(move)

    engine.quit()

    return board.result()


###############################################
# MAIN
###############################################
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--model", type=str, default="../policy_value_sf.pt")
    parser.add_argument("--stockfish", type=str, default="/usr/games/stockfish")
    parser.add_argument("--games", type=int, default=5)
    parser.add_argument("--sims", type=int, default=32)
    args = parser.parse_args()

    device = "cuda" if torch.cuda.is_available() else "cpu"
    print(f"Using device: {device}")

    # Load model
    model = PolicyValueNet().to(device)
    raw = torch.load(args.model, map_location=device)
    fixed = {k.replace("module.", ""): v for k, v in raw.items()}
    model.load_state_dict(fixed)
    model.eval()

    LEVELS = list(range(1, 8 + 1))  # 1 to 8
    print(f"Evaluating against Stockfish levels: {LEVELS}")
    all_results = {}

    for lvl in LEVELS:
        print(f"\n===== Evaluating Stockfish Level {lvl} =====\n")
        results = {"1-0": 0, "0-1": 0, "1/2-1/2": 0}

        for g in range(args.games):
            model_white = (g % 2 == 0)

            res = play_game_at_level(
                model=model,
                sf_path=args.stockfish,
                sf_level=lvl,
                model_white=model_white,
                sims=args.sims,
                device=device,
            )

            results[res] += 1
            print(f"Game {g+1}/{args.games}: {res}")

        all_results[lvl] = results
        print(f"Results vs SF {lvl}: {results}")

    # Final summary
    print("\n\n========== FINAL SUMMARY (SF 1–8) ==========\n")
    print(f"{'Lvl':<5}{'W':<4}{'L':<4}{'D':<4}")
    print("-" * 20)
    for lvl in LEVELS:
        r = all_results[lvl]
        print(f"{lvl:<5}{r['1-0']:<4}{r['0-1']:<4}{r['1/2-1/2']:<4}")


if __name__ == "__main__":
    main()

